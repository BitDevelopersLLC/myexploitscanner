/*
Users Table
ACTIVE
0 = not able to log in
1 = able to log in
STATUS
0 = created - Set to 0 when the record is first created and the user should be sent an activation email.
1 = active and able to log in - The user has clicked a link to activate the account and can now log in
2 = email sent - The user has been sent an activation email.

Scans Table
STATUS - I have space between these numbers to allow for additions to be placed in order.
0 = request created - “Request Created” should be displayed by status. This record should be added to the query for scans that need to be completed.
10 = scan started - “In Progress” should be displayed for status. This record has been gathered by the scanner and a result is in progress.
20 = scan completed - “View Report” should be displayed for status. The scan results are available in a file named the same as the scan_guid field in the db.
100 = scan error - “Error” should be displayed for status. This is considered a completed action.

 */

import com.google.gson.Gson;
import com.google.gson.JsonObject;


import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.*;

public class exploitscanner {

    // Read the configuration from the config.json settings
    static String db_url = getJSONConfigString("db_url");
    static String db_user = getJSONConfigString("db_user");
    static String db_password = getJSONConfigString("db_password");

    public static String getLocalPath(String fileName) {
        // Use this function to get the local path, if it does not
        // find the file, it will use the DEV version of the file path

        String pathToFile = "";

        Path filePath = Paths.get(System.getProperty("user.dir"), fileName);

        if (Files.exists(filePath) == true || Files.isDirectory(filePath)==true) {
            pathToFile = filePath.toString();
        } else {
            pathToFile = getLocalPath_DEV() + "\\" + fileName;
        }

        //System.out.println(pathToFile);

        return pathToFile;

    }
    public static String getLocalPath_DEV() {
        // This is the DEV version of the file path

        String classpath = System.getProperty("java.class.path");

        //System.out.println("getLocalPath_DEV(1):" + classpath);

        // Split the classpath using the path separator
        String[] classpathEntries = classpath.split(
                System.getProperty("path.separator"));

        // Check if there are any entries
        if (classpathEntries.length > 0) {
            // Get the first classpath entry
            classpath = classpathEntries[0];
        } else {
            classpath = "";
        }

        return classpath;

    }
    public static String readTextFile(String pathToFile) {
        // Given a full path including file name of a file, this function will
        // read the file into a string ans return the string.

        String fileContent = "";

        try (BufferedReader reader = new BufferedReader(
                new FileReader(pathToFile))) {
            StringBuilder stringBuilder = new StringBuilder();
            String line;

            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line);
                // Add newline character for each line (optional).
                stringBuilder.append("\n");
            }

            fileContent = stringBuilder.toString();

        } catch (IOException e) {
            e.printStackTrace();
            // TODO: Write this to a log file
        }

        return fileContent;
    }
    public static String getJSONConfigString(String configName) {

        Gson gson = new Gson();

        // Convert JSON string to Java object
        String jsonString = readTextFile( getLocalPath("config.json"));
        JsonObject jsonObject = gson.fromJson(jsonString, JsonObject.class);

        return jsonObject.get(configName).toString().replace("\"","");

    }

    static class Scanner {
        protected String scan_key = "";
        protected String scan_guid = "";
        protected String scan_scantype_ID = "";
        protected String scan_uri = "";
        protected String scan_user_ID = "";
        protected String scanReport = "";

        // Custom constructor, force object to have these values set
        public Scanner(String scan_key
                , String scan_guid
                , String scan_scantype_ID
                , String scan_uri
                , String scan_user_ID) {
            this.scan_key = scan_key;
            this.scan_guid = scan_guid;
            this.scan_scantype_ID = scan_scantype_ID;
            this.scan_uri = scan_uri;
            this.scan_user_ID = scan_user_ID;

        }

        // method to perform actual scan
        public void doScan() {
            // This is just a placeholder for the method to be overridden
        };

        public void writeReportToDisk() {
            // This method will take the returned results and create the
            // file holding the report. If the report directory is not yet
            // created, then create it.
            String reportFolder = getLocalPath("reports");
            reportFolder = reportFolder.replace(".\\","");
            // System.out.println(reportFolder);

            Path folder = Paths.get(reportFolder);
            String fileWithPath = reportFolder + File.separator + this.scan_guid + ".report";

            //System.out.println(fileWithPath);

            if (Files.exists(folder) == false
                    || Files.isDirectory(folder)==false) {
                // Create Folder
                try {
                    Files.createDirectories(folder);
                } catch (IOException e) {
                    e.printStackTrace();
                    // TODO: Write this to a log file
                }
            }

            // Now save
            try {
                // Create a FileWriter with the file path
                FileWriter fileWriter = new FileWriter(fileWithPath);

                // Wrap the FileWriter in a BufferedWriter for efficient writing
                BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

                // Write content to the file
                bufferedWriter.write(scanReport);

                // Close the BufferedWriter to flush and close the file
                bufferedWriter.close();

            } catch (IOException e) {
                e.printStackTrace();
                // TODO: Write this to a log file
            }

        }

        public void updateScanStatus(String status) {
            // Update status of scan in db to In Progress
            try (Connection conn = DriverManager.getConnection(db_url, db_user, db_password)) {
                String mySql = "{CALL scan_update_status(?,?)}";
                CallableStatement cStatement = conn.prepareCall(mySql);
                cStatement.setInt(1,Integer.parseInt(scan_key));
                cStatement.setInt(2,Integer.parseInt(status));
                boolean result = cStatement.execute();

            } catch (SQLException e) {
                e.printStackTrace();
                // TODO: Write this to a log file
            }
        }
    }

    static class Scanner_NMAP extends Scanner {
        // This version of scanner will run a nmap command and save results

        public Scanner_NMAP(String scan_key
                , String scan_guid
                , String scan_scantype_ID
                , String scan_uri
                , String scan_user_ID) {
            super(scan_key
                    , scan_guid
                    , scan_scantype_ID
                    , scan_uri
                    , scan_user_ID);

        }

        public void doScan() {
            String currentScanStatus = "10";

            try {

                // Need to figure out how to implement this into the actual environment (this is the path I have to find
                // Nmap, I couldn't get it to work without this
                String nmapFullPath = "C:\\Program Files (x86)\\Nmap\\Nmap.exe";
                String commandString = "\"" + nmapFullPath + "\" -sV " + this.scan_uri;
                String[] command = {"cmd.exe", "/c", commandString};

                ProcessBuilder processBuilder = new ProcessBuilder(command);
                // To handle both stdout and stderr in the inputStream reader.
                processBuilder.redirectErrorStream(true);
                Process process = processBuilder.start();

                StringBuilder output = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }

                int exitValue = process.waitFor();
                if (exitValue == 0) {
                    this.scanReport = output.toString();
                    // Scan completed successfully
                    currentScanStatus = "20";
                } else {
                    // If there's an error, include more information if possible
                    this.scanReport = "Error during scan execution. Exit value: " + exitValue + ". Output: " + output.toString();
                    // Indicate error
                    currentScanStatus = "100";
                }
            } catch (Exception e) {
                e.printStackTrace();
                this.scanReport = "Exception caught during scan: " + e.getMessage();
                // Indicate error
                currentScanStatus = "100";
            }

            this.writeReportToDisk();
            this.updateScanStatus(currentScanStatus);
        }
    }

        public static void main(String[] args) {
        // This is the main function that will run when program is run.
        // It requires the scan_key field from the db record.
        String scan_key = args[0];

        // Here are the scan data items from the database record
        String scan_guid = "";
        String scan_scantype_ID = "";
        String scan_uri = "";
        String scan_user_ID = "";

        // Get the scan parameters
        try (Connection conn = DriverManager.getConnection(db_url, db_user, db_password)) {
            String mySql = "{CALL scan_view_bykey(?)}";
            PreparedStatement pStatement = conn.prepareCall(mySql);
            pStatement.setInt(1,Integer.parseInt(scan_key));
            ResultSet rs = pStatement.executeQuery();
            while (rs.next()) {
                // Get the scan details
                scan_guid = rs.getString("scan_guid");
                scan_scantype_ID = rs.getString("scan_scantype_ID");
                scan_uri = rs.getString("scan_uri");
                scan_user_ID = rs.getString("scan_user_ID");
                System.out.println(scan_guid + " " + scan_scantype_ID + " " + scan_uri + " " + scan_user_ID + " ");
            }
        } catch (SQLException e) {
            e.printStackTrace();
            // TODO: Write this to a log file
        }

        // Create a scan object instance based on Scan Type
        Scanner thisScan = new Scanner(scan_key
                , scan_guid
                , scan_scantype_ID
                , scan_uri
                , scan_user_ID);
        // TODO: Make sure the CASE instances match up with ScanType records
        switch (Integer.parseInt(scan_scantype_ID)) {
            case 1: // This is the scantype_key
                thisScan = new Scanner_NMAP(scan_key
                        , scan_guid
                        , scan_scantype_ID
                        , scan_uri
                        , scan_user_ID);
                break;
            default:
                // No valid Scan Type Coded
                // TODO: Need to log and notify if this issue comes up
        }

        // Update scan status to 10 for in progress
        thisScan.updateScanStatus("10");

        // Run the Scan
        thisScan.doScan();

        // This scan should be completed now and this instance can exit
        // TODO: Write to log that the scan we completed successfully.

    }

}